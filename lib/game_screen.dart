/* import 'dart:async'; // Imports asynchronous functionalities like Future and Timer.
import 'dart:math'; // Imports the Random class to generate random numbers.
import 'package:flutter/material.dart'; // Imports Flutter's Material Design framework.

// Defines the main game screen as a StatefulWidget.
// A StatefulWidget is a widget that has mutable state, meaning it can change during the widget's lifetime.
class GameScreen extends StatefulWidget {
  // Constant constructor for the widget.
  const GameScreen({super.key});

  // Creates the mutable state for this widget.
  @override
  State<GameScreen> createState() => _GameScreenState();
}
/*  */
// The State class contains the logic and internal state for the GameScreen.
class _GameScreenState extends State<GameScreen> {
  // --- CONFIGURATION AND STATE VARIABLES ---

  // List of base colors for the quadrants. The order is important (0: green, 1: red, etc.).
  final List<Color> _colors = const [
    Colors.green, // 0
    Colors.red,   // 1
    Colors.yellow,// 2
    Colors.blue,  // 3
  ];

  // List of colors to be displayed when a quadrant lights up (brighter).
  final List<Color> _activeColors = const [
    Colors.lightGreenAccent,
    Color(0xFFFF5252),
    Colors.yellowAccent,
    Colors.lightBlueAccent,
  ];

  // --- GAME STATE VARIABLES ---

  List<int> _gameSequence = []; // Stores the color sequence generated by the game.
  List<int> _playerSequence = []; // Stores the color sequence entered by the player.
  int _level = 0; // Current game level.
  bool _isPlayerTurn = false; // Indicates if it's the player's turn to input the sequence.
  bool _gameInProgress = false; // Indicates if a game is currently in progress.
  int? _activeColorIndex; // Stores the index of the currently lit color. It's `null` if none are lit.
  String _message = "START"; // Message displayed on the central button.

  // --- GAME LOGIC ---

  // Starts a new game, resetting the state variables.
  void _startGame() {
    setState(() {
      _gameInProgress = true;
      _level = 0;
      _gameSequence = [];
      _nextLevel(); // Proceeds to the first level.
    });
  }

  // Prepares the next level of the game.
  void _nextLevel() {
    setState(() {
      _level++; // Increments the level.
      _message = "$_level"; // Displays the current level in the center.
      _playerSequence = []; // Resets the player's sequence for the new level.
      _isPlayerTurn = false; // It's not the player's turn yet.
    });

    // Adds a new random color (0, 1, 2, or 3) to the game sequence.
    final random = Random();
    _gameSequence.add(random.nextInt(4));

    // Displays the visual sequence to the player.
    _playSequence();
  }

  // Plays the color sequence visually. It's asynchronous to allow for pauses.
  Future<void> _playSequence() async {
    // Initial pause for the player to get ready.
    await Future.delayed(const Duration(milliseconds: 600));

    // Iterates over each color in the game sequence.
    for (int colorIndex in _gameSequence) {
      await _lightUpQuadrant(colorIndex); // Lights up the corresponding quadrant.
      // Pause between lighting up each color to make it noticeable.
      await Future.delayed(const Duration(milliseconds: 300));
    }

    // Once the sequence is finished, it's the player's turn.
    setState(() {
      _isPlayerTurn = true;
      _message = "YOUR TURN!";
    });
  }

  // Controls the visual effect of lighting up a quadrant.
  Future<void> _lightUpQuadrant(int colorIndex) async {
    // Updates the state so the widget rebuilds with the active color.
    setState(() => _activeColorIndex = colorIndex);
    
    // Keeps the color lit for 400 milliseconds.
    await Future.delayed(const Duration(milliseconds: 400));
    // Sets `_activeColorIndex` back to null to turn off the quadrant.
    setState(() => _activeColorIndex = null);
  }

  // Executes when the player taps a quadrant.
  void _onPlayerTap(int colorIndex) {
    // Ignores the tap if it's not the player's turn or if no game is in progress.
    if (!_isPlayerTurn || !_gameInProgress) return;

    _lightUpQuadrant(colorIndex); // Lights up the quadrant the player tapped.
    _playerSequence.add(colorIndex); // Adds the color to the player's sequence.

    _checkPlayerSequence(); // Checks if the tap was correct.
  }

  // Checks the player's sequence against the game's sequence.
  void _checkPlayerSequence() {
    int currentTapIndex = _playerSequence.length - 1;

    // Checks if the player's last tap matches the corresponding color in the game's sequence.
    if (_playerSequence[currentTapIndex] != _gameSequence[currentTapIndex]) {
      _gameOver(); // If it doesn't match, the game is over.
      return;
    }

    // If the player has entered the complete sequence correctly...
    if (_playerSequence.length == _gameSequence.length) {
      setState(() {
        _isPlayerTurn = false; // It's no longer the player's turn.
        _message = "GOOD!";
      });
      // Waits for a second and proceeds to the next level.
      Future.delayed(const Duration(seconds: 1), _nextLevel);
    }
  }

  // Ends the game and resets the state.
  void _gameOver() {
    setState(() {
      _message = "FAIL\nLevel $_level"; // Displays the Game Over message and the level reached.
      _isPlayerTurn = false;
      _gameInProgress = false;
    });

    // After 2 seconds, resets the message to "START" to allow a new game to begin.
    Future.delayed(const Duration(seconds: 2), () {
      // `mounted` checks if the widget is still in the widget tree.
      if (mounted && !_gameInProgress) {
        setState(() {
          _message = "START";
        });
      }
    });
  }


  // --- UI CONSTRUCTION ---

  // The build method is called every time the UI needs to be rebuilt (e.g., with setState).
  @override
  Widget build(BuildContext context) {
    // Gets the screen width to make the layout responsive.
    final double screenWidth = MediaQuery.of(context).size.width;
    // The game board size will be 90% of the screen width.
    final double gameSize = screenWidth * 0.9; 

    return Scaffold(
      // Center ensures the game is centered on the screen.
      body: Center(
        child: SizedBox(
          width: gameSize,
          height: gameSize,
          // Stack allows widgets to be stacked on top of each other.
          child: Stack(
            children: [
              // Builds the 4 color quadrants, one in each corner.
              _buildQuadrant(0, Alignment.topLeft),
              _buildQuadrant(1, Alignment.topRight),
              _buildQuadrant(2, Alignment.bottomLeft),
              _buildQuadrant(3, Alignment.bottomRight),

              // Builds the central control button.
              Center(
                // GestureDetector detects taps on the central button.
                child: GestureDetector(
                  // The onTap function is only active if no game is in progress.
                  onTap: _gameInProgress ? null : _startGame,
                  child: Container(
                    width: gameSize * 0.4, // 40% of the game size.
                    height: gameSize * 0.4,
                    decoration: const BoxDecoration(
                      color: Colors.white,
                      shape: BoxShape.circle, // Circular shape.
                      boxShadow: [ // Shadow to give it depth.
                        BoxShadow(color: Colors.black54, blurRadius: 8, spreadRadius: 2)
                      ],
                    ),
                    child: Center(
                      child: Text(
                        _message, // Displays the current message (START, level, YOUR TURN!, etc.).
                        textAlign: TextAlign.center,
                        style: TextStyle(
                          fontSize: gameSize * 0.1, // Responsive font size.
                          fontWeight: FontWeight.bold,
                          color: Colors.black87,
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper method to build each of the 4 quadrants.
  Widget _buildQuadrant(int colorIndex, Alignment alignment) {
    BorderRadius borderRadius;
    // Determines the corner radius based on the alignment to form the circle.
    switch (alignment.toString()) {
      case 'Alignment.topLeft':
        borderRadius = const BorderRadius.only(topLeft: Radius.circular(1000));
        break;
      case 'Alignment.topRight':
        borderRadius = const BorderRadius.only(topRight: Radius.circular(1000));
        break;
      case 'Alignment.bottomLeft':
        borderRadius = const BorderRadius.only(bottomLeft: Radius.circular(1000));
        break;
      case 'Alignment.bottomRight':
        borderRadius = const BorderRadius.only(bottomRight: Radius.circular(1000));
        break;
      default:
        borderRadius = BorderRadius.zero;
    }

    // Align positions the quadrant in the corresponding corner of the Stack.
    return Align(
      alignment: alignment,
      // GestureDetector detects the player's tap on this quadrant.
      child: GestureDetector(
        onTap: () => _onPlayerTap(colorIndex),
        // FractionallySizedBox makes the widget occupy half the width and height of its parent (the Stack).
        child: FractionallySizedBox(
          widthFactor: 0.5,
          heightFactor: 0.5,
          child: Container(
            decoration: BoxDecoration(
              // The color changes to a brighter one if `_activeColorIndex` matches this quadrant.
              color: _activeColorIndex == colorIndex ? _activeColors[colorIndex] : _colors[colorIndex],
              borderRadius: borderRadius,
              border: Border.all(color: Colors.black, width: 4), // Border to separate the quadrants.
            ),
          ),
        ),
      ),
    );
  }
}

 */